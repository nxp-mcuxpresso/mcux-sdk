import argparse
import struct
import os
import binascii

from Crypto.PublicKey import RSA
from Crypto.Util import number

def write_public_key_c_file(c_file_name):
    CERTIFICATE_MARKER = 0xCE27CE27
    header = '''\
    /* AUTOGENERATED FILE DO NOT EDIT */
    '''

    with open(c_file_name, 'w') as source:
        header = '''\
        /* AUTOGENERATED FILE DO NOT EDIT */
        '''
        array_name = c_file_name.split(".")[0]
        source.write(header)

        source.write('#include <stdint.h>\n')

        source.write('const uint32_t ')
        source.write(array_name)
        source.write('[] = {')

        for i, x in enumerate(struct.unpack('<64L', number.long_to_bytes(key.n)[::-1])):
            if i % 4 == 0:
                source.write('\n    ')
            source.write('0x{:08x}, '.format(x))

        source.write('\n};\n')

def write_psect_img_pk_write_cmd(cmd):
    with open(cmd, 'w') as psectcmd:
        psectcmd.write('#!/bin/bash\r\n');
        psectcmd.write('echo "Only use this command to set or replace the public key when :";')
        psectcmd.write('echo "    1) a direct authentication method is used or";')
        psectcmd.write('echo "    2) when indirect authentication method is used it will set/replace the key that is used to authenticate the certificate containing the key.";')
        psectcmd.write('DK6Programmer.exe -Y -V 2 -s $1 -w image_key_value=')
        #write octet string in big-enddian becasue this is the byte actual order
        for i, x in enumerate(struct.unpack('>64L', number.long_to_bytes(key.n)[::-1])):
            psectcmd.write('{:08x}'.format(x))

parser = argparse.ArgumentParser(description='RSA Key Generator')
parser.add_argument('-k', '--key_path')
parser.add_argument('-p', '--password')

args = parser.parse_args()



if os.path.isdir(args.key_path) == False:
    try:
        os.mkdir(args.key_path)
    except OSError:
        print ("Creation of the directory %s failed" % args.key_path)
    else:
        #exponent 3 is mandatory a shortcut is taken in the verification code of the boot ROM
        key = RSA.generate(2048, e=3)

        private_key_file=args.key_path+"/priv_key.pem"
        public_key_c_file=args.key_path+"/pub_key.c"
        public_key_psectcmd=args.key_path+"/pub_key_psect.sh"

        with open(private_key_file, 'w') as key_file:
            key_file.write((key.exportKey('PEM', args.password)).decode('utf-8'))

        # generate DK6Programmer command to set the image_pub_key in the PSECT
        # Only use this command to set or repalce the public key when :
        #      1) a direct authentication method is used or
        #      2) when indirect authentication method is used it will set/replace the key
        #         that is used to authenticate the certificate containing the key.
        write_psect_img_pk_write_cmd(public_key_psectcmd)

        write_public_key_c_file(public_key_c_file)
else:
    print ("The key directory %s already exists" % args.key_path)
