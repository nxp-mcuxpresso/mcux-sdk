import argparse
import struct
import os
import binascii

from Crypto.Signature import pkcs1_15
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
from Crypto.Util import number


#creates the certificate.c file for the certificate

def write_cert_c_file(c_file_name, customer_id, device_min, device_max, exported_key, sign_key):
     CERTIFICATE_MARKER = 0xCE27CE27
     header = '''\
     /* AUTOGENERATED FILE DO NOT EDIT */
     '''

     certificate_struct = struct.Struct('<LLLLQQQ')

     with open(c_file_name, 'w') as source:
         source.write(header)

         source.write('#include <stdint.h>\n')
         source.write('#include "rom_secure.h"\n')
         source.write('#include "rsa_enc_dec.h"\n\n')

         source.write('const IMAGE_CERT_T cert =\n')
         source.write('{\n')
         source.write('    .certificate_marker=CERTIFICATE_MARKER,\n')
         source.write('    .certificate_id=0x{:08x},\n'.format(0))
         source.write('    .usage_flags=0x{:08x},\n'.format(0))
         source.write('    .reserved=0x{:08x},\n'.format(0))
         source.write('    .customer_id=0x{:016x},\n'.format(customer_id))
         source.write('    .min_device_id=0x{:016x},\n'.format(device_min))
         source.write('    .max_device_id=0x{:016x},'.format(device_max))
         source.write('\n  .public_key={')

         for i, x in enumerate(struct.unpack('<64L', number.long_to_bytes(public_key.n)[::-1])):
             if i % 4 == 0:
                 source.write('\n        ')
         source.write('0x{:08x}, '.format(x))

         source.write('\n    }\n')
         source.write('};\n')

def write_cert_bin_file(bin_file_name, customer_id, device_min, device_max, exported_key, sign_key):

    certificate_struct = struct.Struct('<LLLLQQQ')
    CERTIFICATE_MARKER = 0xCE27CE27

    certificate = certificate_struct.pack(
         CERTIFICATE_MARKER,
         0,
         0,
         0,
         customer_id,
         device_min,
         device_max
    )

    certificate = certificate + exported_key

    hash = SHA256.new(certificate)
    signer = pkcs1_15.new(sign_key)
    signature = signer.sign(hash)

    certificate = certificate + signature
    try:
        with open(bin_file_name, 'wb') as out_file:
            out_file.write(certificate)
    except IOError:
         print("certificate File not writable")



parser = argparse.ArgumentParser(description='DK6 Certificate Generator: for JN5189, QN9090, K32W061 processors')
parser.add_argument('--cert_path')
parser.add_argument('--key')
parser.add_argument('--password')
parser.add_argument('--customer', type=int, default=0)
parser.add_argument('--device_min', type=int, default=0);
parser.add_argument('--device_max', type=int, default=0xFFFFFFFFFFFFFFFF)

args = parser.parse_args()
# args.key is the key used to sign the certificate
if args.key is None:
     print("Key File name must be provided to sign the certificate that is to be generated")
else:
    try:
        key_file_path = args.key
        with open(key_file_path, 'r') as key_file:
             key = RSA.importKey(key_file.read(), args.password)
    except IOError:
         print("Key File not accessible")
    else:
        if os.path.isdir(args.cert_path) == False:
            try:
                 os.mkdir(args.cert_path)
            except OSError:
                 print ("Creation of the directory %s failed" % args.cert_path)
            else:
                #exponent 3 is mandatory a shortcut is taken in the verification code of the boot ROM
                cert_key = RSA.generate(2048, e=3)

                private_key_file=args.cert_path+"/priv_key.pem"
                public_cert_c_file=args.cert_path+"/certificate.c"
                public_cert_bin_file=args.cert_path+"/cert.bin"

                with open(private_key_file, 'w') as key_file:
                    key_file.write((cert_key.exportKey('PEM', args.password)).decode('utf-8'))


                #get public key of certificate
                public_key = cert_key.publickey()
                exported_key = number.long_to_bytes(public_key.n, 256)[::-1]

                #private certificate key is exported
                with open(private_key_file, 'w') as oem_key_file:
                    oem_key_file.write((cert_key.exportKey('PEM', args.password)).decode('utf-8'))

                write_cert_bin_file(public_cert_bin_file, args.customer, args.device_min,args. device_max, exported_key, key)
        else:
             print (args.cert_path + " already exists! Provide another path or destroy it first")
