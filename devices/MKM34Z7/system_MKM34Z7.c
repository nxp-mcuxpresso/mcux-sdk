/*
** ###################################################################
**     Processors:          MKM34Z256VLL7
**                          MKM34Z256VLQ7
**
**     Compilers:           Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          IAR ANSI C/C++ Compiler for ARM
**                          Keil ARM C/C++ Compiler
**                          MCUXpresso Compiler
**
**     Reference manual:    KM34P144M75SF0RM, Rev.1, Jan 2015
**     Version:             rev. 1.2, 2015-03-06
**     Build:               b201125
**
**     Abstract:
**         Provides a system configuration function and a global variable that
**         contains the system frequency. It configures the device and initializes
**         the oscillator (PLL) that is part of the microcontroller device.
**
**     Copyright 2016 Freescale Semiconductor, Inc.
**     Copyright 2016-2020 NXP
**     All rights reserved.
**
**     SPDX-License-Identifier: BSD-3-Clause
**
**     http:                 www.nxp.com
**     mail:                 support@nxp.com
**
**     Revisions:
**     - rev. 1.0 (2014-10-17)
**         Initial version.
**     - rev. 1.1 (2015-01-27)
**         Update according to reference manual rev. 1, RC.
**     - rev. 1.2 (2015-03-06)
**         Update according to reference manual rev. 1.
**
** ###################################################################
*/

/*!
 * @file MKM34Z7
 * @version 1.2
 * @date 2015-03-06
 * @brief Device specific configuration file for MKM34Z7 (implementation file)
 *
 * Provides a system configuration function and a global variable that contains
 * the system frequency. It configures the device and initializes the oscillator
 * (PLL) that is part of the microcontroller device.
 */

#include <stdint.h>
#include "fsl_device_registers.h"

/* ----------------------------------------------------------------------------
   -- Core clock
   ---------------------------------------------------------------------------- */

uint32_t SystemCoreClock = DEFAULT_SYSTEM_CLOCK;

/* ----------------------------------------------------------------------------
   -- SystemInit()
   ---------------------------------------------------------------------------- */

void SystemInit(void)
{
#if (DISABLE_WDOG)
    /* WDOG->UNLOCK: WDOGUNLOCK=0xC520 */
    WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xC520); /* Key 1 */
    /* WDOG->UNLOCK: WDOGUNLOCK=0xD928 */
    WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xD928); /* Key 2 */
    /* WDOG->STCTRLH:
     * ?=0,DISTESTWDOG=0,BYTESEL=0,TESTSEL=0,TESTWDOG=0,?=0,?=1,STOPEN=1,DBGEN=0,ALLOWUPDATE=1,WINEN=0,IRQRSTEN=0,CLKSRC=1,WDOGEN=0
     */
    WDOG->STCTRLH = WDOG_STCTRLH_BYTESEL(0x00) | WDOG_STCTRLH_STOPEN_MASK | WDOG_STCTRLH_ALLOWUPDATE_MASK |
                    WDOG_STCTRLH_CLKSRC_MASK | 0x0100U;
#endif /* (DISABLE_WDOG) */

    SystemInitHook();
}

/* ----------------------------------------------------------------------------
   -- SystemCoreClockUpdate()
   ---------------------------------------------------------------------------- */

void SystemCoreClockUpdate(void)
{
    uint32_t MCGOUTClock; /* Variable to store output clock frequency of the MCG module */
    uint16_t Divider;

    if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x00U)
    {
        /* Output of FLL or PLL is selected */
        if ((MCG->C6 & MCG_C6_PLLS_MASK) == 0x00U)
        {
            /* FLL is selected */
            if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)
            {
                /* External reference clock is selected */
                if ((MCG->C7 & MCG_C7_OSCSEL_MASK) != 0x00U)
                {
                    MCGOUTClock = CPU_XTAL32k_CLK_HZ; /* RTC 32 kHz oscillator drives MCG clock */
                }
                else
                {
                    MCGOUTClock = CPU_XTAL_CLK_HZ; /* System oscillator drives MCG clock */
                }
                if (((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x00U) && ((MCG->C7 & MCG_C7_OSCSEL_MASK) != 0x01U))
                {
                    switch (MCG->C1 & MCG_C1_FRDIV_MASK)
                    {
                        case 0x38U:
                            Divider = 1536U;
                            break;
                        case 0x30U:
                            Divider = 1280U;
                            break;
                        default:
                            Divider = (uint16_t)(32LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
                            break;
                    }
                }
                else
                { /* ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x00U) */
                    Divider = (uint16_t)(1LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
                }
                MCGOUTClock = (MCGOUTClock / Divider); /* Calculate the divided FLL reference clock */
            }
            else
            {                                      /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
                MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* The slow internal reference clock is selected */
            }                                      /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x00U)) */
            /* Select correct multiplier to calculate the MCG output clock  */
            switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK))
            {
                case 0x00U:
                    MCGOUTClock *= 640U;
                    break;
                case 0x20U:
                    MCGOUTClock *= 1280U;
                    break;
                case 0x40U:
                    MCGOUTClock *= 1920U;
                    break;
                case 0x60U:
                    MCGOUTClock *= 2560U;
                    break;
                case 0x80U:
                    MCGOUTClock *= 732U;
                    break;
                case 0xA0U:
                    MCGOUTClock *= 1464U;
                    break;
                case 0xC0U:
                    MCGOUTClock *= 2197U;
                    break;
                case 0xE0U:
                    MCGOUTClock *= 2929U;
                    break;
                default:
                    MCGOUTClock *= 640U;
                    break;
            }
        }
        else
        { /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x00U)) */
            /* PLL is selected */
            if ((MCG->C7 & MCG_C7_PLL32KREFSEL_MASK) == 0x00U)
            {
                /* RTC 32 kHz oscillator selected */
                MCGOUTClock = CPU_XTAL32k_CLK_HZ;
            }
            else if ((MCG->C7 & MCG_C7_PLL32KREFSEL_MASK) == 0x40U)
            {
                /* 32kHz IRC selected */
                MCGOUTClock = CPU_INT_SLOW_CLK_HZ;
            }
            else if ((MCG->C7 & MCG_C7_PLL32KREFSEL_MASK) == 0x80U)
            {
                /* FLL FRDIV selected */
                if ((MCG->C7 & MCG_C7_OSCSEL_MASK) != 0x00U)
                {
                    MCGOUTClock = CPU_XTAL32k_CLK_HZ; /* RTC 32 kHz oscillator drives MCG clock */
                }
                else
                {
                    MCGOUTClock = CPU_XTAL_CLK_HZ; /* System oscillator drives MCG clock */
                }
                if (((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x00U) && ((MCG->C7 & MCG_C7_OSCSEL_MASK) != 0x01U))
                {
                    switch (MCG->C1 & MCG_C1_FRDIV_MASK)
                    {
                        case 0x38U:
                            Divider = 1536U;
                            break;
                        case 0x30U:
                            Divider = 1280U;
                            break;
                        default:
                            Divider = (uint16_t)(32LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
                            break;
                    }
                }
                else
                { /* ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x00U) */
                    Divider = (uint16_t)(1LU << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
                }
                MCGOUTClock = (MCGOUTClock / Divider); /* Calculate the divided FLL reference clock */
            }
            else
            { /* (MCG->C7 & MCG_C7_PLL32KREFSEL_MASK) == 0xB0U */
                /* Reserved value */
                return;
            }
            MCGOUTClock *= 375U; /* Calculate the MCG output clock */
        }
    }
    else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40U)
    {
        /* Internal reference clock is selected */
        if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)
        {
            MCGOUTClock = CPU_INT_SLOW_CLK_HZ; /* Slow internal reference clock selected */
        }
        else
        { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
            Divider     = (uint16_t)(0x01LU << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));
            MCGOUTClock = (uint32_t)(CPU_INT_FAST_CLK_HZ / Divider); /* Fast internal reference clock selected */
        }                                                            /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x00U)) */
    }
    else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U)
    {
        /* External reference clock is selected */
        if ((MCG->C7 & MCG_C7_OSCSEL_MASK) != 0x00U)
        {
            MCGOUTClock = CPU_XTAL32k_CLK_HZ; /* RTC 32 kHz oscillator drives MCG clock */
        }
        else
        {
            MCGOUTClock = CPU_XTAL_CLK_HZ; /* System oscillator drives MCG clock */
        }
    }
    else
    { /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U)) */
        /* Reserved value */
        return;
    } /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80U)) */
    SystemCoreClock =
        (MCGOUTClock / (0x01U + ((SIM->CLKDIV1 & SIM_CLKDIV1_CLKDIVSYS_MASK) >> SIM_CLKDIV1_CLKDIVSYS_SHIFT)));
}

/* ----------------------------------------------------------------------------
   -- SystemInitHook()
   ---------------------------------------------------------------------------- */

__attribute__((weak)) void SystemInitHook(void)
{
    /* Void implementation of the weak function. */
}
